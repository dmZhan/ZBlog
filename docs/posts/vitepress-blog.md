---
title: VitePress利用默认主题拓展开发博客实录
date: 2023-04-30
description: VitePress利用默认主题拓展开发博客实录
tags:
  - VitePress
---

# VitePress利用默认主题拓展开发博客实录

![cover](https://s2.loli.net/2023/04/30/KQrvZSeBiFujawC.webp)

> 本文使用VitePress v1.0.0-beta.1，VitePress仍在开发中，请留意更新。

## Before the start

这篇博客的目的是给出自定义VitePress博客主题的注意事项，但是如果想构建一个完整的项目你仍然需要熟悉VitePress文档。

这个博客项目参考了许多博客和GitHub仓库，我会使用外链表明参考对象。

如果你觉得我的这篇博客和项目对你有帮助的话，不妨为我的[GitHub](https://github.com/aiktb/rea)点个Star⭐！

### Q&A

Q: 用VitePress构建自定义主题的博客有哪些优点？

A: 开箱即用、所需技术门槛低、SPA加载速度快以及构建速度快。

Q: 需要掌握哪些技术才能自定义主题？

A: 最基本的`CSS`、`HTML`和`JavaScript`，这里使用的所有`TypeScript`都可以很简单的更换为JavaScript，无需任何顾虑。

Q: 有哪些有价值的文档可以参考？

A: [GitHub Issue](https://github.com/vuejs/vitepress/issues)、[VitePress Docs](https://vitepress.dev/)、[MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web)。

Q: 如何部署博客到公网？

A: 建议使用[GitHub Action](https://docs.github.com/en/actions)和`github.io`的子域名即可，不需要任何花费。

### Tool Box

| Name                                              | Features                                                           |
| ------------------------------------------------- | ------------------------------------------------------------------ |
| [Typora](https://typora.io/)                      | 所见即所得的markdown编辑器，简洁美观，功能齐全。                   |
| [Canva](https://www.canva.com/)                   | 用于设计博客所用的封面图片，提供云保存、在线编辑和大量免费模板。   |
| [IconScout](https://iconscout.com/)               | 搜寻博客需要使用的各种SVG图标，免费图标就够用。                    |
| [SM.MS](https://sm.ms/)                           | 免费的在线图床服务，如果不想将图片保存在GitHub Repo的话很有用。    |
| [PicGo-APP](https://github.com/Molunerfinn/PicGo) | 和Typora配合实现粘贴图片自动转换为Webp并上传到多种图床。           |
| [Figma](https://www.figma.com/)                   | SVG编辑器有很多，真的好用还得是Figma。                             |
| [ChatGPT](https://chat.openai.com/chat)           | 提供各种关于编码的建议，如果你没有太多前端开发经验，那么这很重要。 |

## Develop

### Getting Started

在WebStorm或VSCode新建一个空项目，执行以下命令：

```bash
npm install -D vitepress
npx vitepress init
```

项目目录结构：

```txt
├─.github
│  └─workflows
├─docs
│  ├─.vitepress
│  │  ├─cache
│  │  ├─dist
│  │  └─theme
│  │      └─components
│  ├─posts
│  └─public
└─node_modules
```

填写目录名称时，`docs`是默认名，该目录在GitHub的代码占比分析中会被忽略，参考[linguist](https://github.com/github-linguist/linguist/blob/master/docs/overrides.md#documentation)，如果你的Repo Languages显示不正常，应该创建`.gitattributes`在你的项目根目录(最外层)，添加类似行：

```txt
docs/** -linguist-documentation
```

这样你的Repo Languages在项目开发完后应该类似：

![repo-languages](https://s2.loli.net/2023/05/16/tJvEQAreSX8mPq7.webp)

::: details tsconfig.json 如果你使用JavaScript那么可以忽略它。

```json
{
  "compilerOptions": {
    "module": "ESNext",
    "target": "ESNext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "skipLibCheck": true,
    /* Linting */
    "strict": true,
    "allowUnreachableCode": false,
    "allowUnusedLabels": false,
    "exactOptionalPropertyTypes": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitOverride": true,
    "noImplicitReturns": true,
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  },
  "include": ["docs/.vitepress/**/*.ts", "docs/.vitepress/**/*.vue"]
}

```

:::

### config.ts

#### sidebar

对于文档而言这是必要的，但对博客而言需要去掉它来节省空间，从`config.ts`中删除以下行关闭它：

```typescript
sidebar: [ // [!code --:10]
    {
		text: 'Guide',
        items: [
            { text: 'Introduction', link: '/introduction' },
            { text: 'Getting Started', link: '/getting-started' }
        ]
    }
]
```

#### lineNumbers

这是我唯一使用的markdown配置，且很有用，我查看了许多人的VitePress项目，发现他们都没有开启代码块行号显示选项，我建议你在`config.ts`中开启它：

```typescript
markdown: {
    lineNumbers: true
}
```

#### dark mode

非常可惜目前的VitePress没有`dark mode only`，只能将主题锁定在明亮模式并通过以下配置移除主题切换按钮：

```typescript
appearance: false
```

我的博客完全是在明亮模式的基础上修改的，为了减少工作量我只愿意开发一套主题，如果VitePress能锁定在dark mode(并且移除切换按钮)，那将可以大大减少我的工作量。

#### head

除去官网介绍的简单添加favicon功能，head还可以做很多事，[MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head)中提到的都是可添加项，用类似下面的方法可以将其添加到你的博客或文档中。

最常用的就是加载外部JavaScript，比如支持[Google Analytics](https://analytics.google.com/analytics/web/)，就像这样：

::: code-group

```typescript [config.ts]
head: [
    [
        'script',
        {async: '', src: 'https://www.googletagmanager.com/gtag/js?id=G-**********'}
    ],
    [
        'script',
        {},
        `window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-**********');`
    ],
]
```

```html [index.html]
<!-- HTML generated by VitePress -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-**********"/></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-**********');
</script>
```

:::

像这样控制Chrome for Android的主题颜色：

```typescript
head: [
    [
        'meta',
        {name: 'theme-color', content: '#4df5ff'}
    ],
]
```

你还可以像这样加载[Google Fonts](https://fonts.google.com/)中的`JetBrains Mono`字体，以便在CSS中直接使用它，以下两种方式都是可行的：

::: code-group

```typescript [&lt;link/&gt;]
head: [
	[
        'link',
        {rel: 'preconnect', href: 'https://fonts.googleapis.com'}
    ],
    [
        'link',
        {rel: 'preconnect', href: 'https://fonts.gstatic.com', crossorigin: ''},
    ],
    [
        'link',
        {rel: 'stylesheet', href: 'https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap'},
    ],
]
```

```typescript [&lt;style/&gt;]
head: [
    [
        'style',
        {},
        `@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap');`
    ],
]
```

:::

#### buildEnd

这个功能可以在VitePress构建完成后调用特定的JavaScript，很适合用来添加类似RSS Feed和Site Map的功能。

我将在这里用几步教会你为博客生成RSS Feed：

1. 运行`npm i -D feed`安装依赖；
2. 编辑`/theme/rss.ts`和`config.ts`文件:

::: code-group


```typescript {4} [config.ts]
import {rss} from './theme/rss'

export default defineConfig({
    buildEnd: rss,
})
```

```typescript [rss.ts]
import path from 'path'
import { writeFileSync } from 'fs'
import { Feed } from 'feed'
import { type ContentData, createContentLoader, type SiteConfig } from 'vitepress'

const id: string = 'aiktb'
const baseUrl: string = `https://${id}.com`
type RssGenerator = (config: SiteConfig) => Promise<void>
export const rss: RssGenerator = async (config) => {
  const feed: Feed = new Feed({
    title: `${id}'s blog`,
    description: 'My Personal Blog',
    id: baseUrl,
    link: baseUrl,
    language: 'zh-CN',
    image: `${baseUrl}/avatar.jpg`,
    favicon: `${baseUrl}/favicon.svg`,
    copyright: `Copyright (c) 2023 ${id}`
  })

  const posts: ContentData[] = await createContentLoader('posts/*.md', {
    excerpt: true,
    render: true,
    transform: (rawData) => {
      return rawData.sort((a, b) => {
        return +new Date(b.frontmatter.date) - +new Date(a.frontmatter.date)
      })
    }
  }).load()

  for (const { url, excerpt, frontmatter, html } of posts) {
    feed.addItem({
      title: frontmatter.title as string,
      id: `${baseUrl}${url}`,
      link: `${baseUrl}${url}`,
      description: excerpt as string,
      content: html as string,
      author: [{ name: `${id}` }],
      date: frontmatter.date
    })
  }

  writeFileSync(path.join(config.outDir, 'rss.xml'), feed.rss2())
}

```

:::

这个方法基本参考了尤雨溪[Vue Blog](https://github.com/vuejs/blog/blob/main/.vitepress/genFeed.ts)源码，但他使用了错误的`'feed.rss'`文件名，应该使用`.xml`格式，否则RSS订阅文件将无法被浏览器正确显示。

并且我的方法依赖每篇文章中开头有如下格式的`frontmatter`，并且博客文章目录名为`posts`，关于`frontmatter`的应用接下来还会详细提到。

```markdown
---
title: 'VitePress Blog Title'
date: 2023-04-30
---
```

> 1. 注意时间格式很重要，不要修改它，那会导致报错。
> 2. Google Search支持使用RSS Feed作为站点地图，没有必要再单独生成sitemap。

#### socialLinks

重要的只有一点：如何引用SVG文件图标为网站添加一个VitePress默认支持以外的图标(比如Telegram、Email)？

图标可以从iconscout找，但VitePress Docs只给出了一种SVG硬编码引用方式，其实有更好的方法。

在Vue和JavaScript文件你都可以类似使用以下的格式引用，这需要你的`viewBox`设置和原始SVG一致并`xlink:href`引用正确的SVG文件名和id：

::: code-group

```typescript {5-8} [config.ts]
themeConfig: {
	socialLinks: [
		{
			icon: {
				svg: `<svg role="img" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                        <title>RSS</title>
                        <use xlink:href="/rss.svg#rss"/>
                      </svg>`
            },
            link: '/rss.xml'
        },
    ]
}
```

```xml {1} [rss.svg]
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" id="rss">
    <path d=" ... "/>
</svg>
```

:::

#### search

新建立的文档和博客还没有内容来充实它，申请[Algolia DocSearch](https://docsearch.algolia.com/docs/what-is-docsearch)有点为难人，不过VitePress就在alpha.66版本加入了`Local Search`功能，可以按照文档的说明简单快捷的启用它，只需要几行代码：

```typescript
 themeConfig: {
    search: {
      provider: 'local'
    }
  }
```

需要注意的是`Local Search`并不完美，仅仅是"能用"而已，还存在许多问题有待解决，特别是中文的处理上表现很糟糕。

以前有[vitepress-plugin-search](https://github.com/emersonbottero/vitepress-plugin-search)插件用于支持本地搜索，我使用过该插件，效果上似乎差距不明显，但在样式上`Local Search`完胜，这能减轻CSS开发工作量。

![search](https://s2.loli.net/2023/04/30/gibULzPQ61pEoZN.webp)

在我的博客大体开发完成后发布了3篇文章时，仅仅过了3个小时Algolia就通过了我的申请，他们的工作效率真的很高:)

但是默认的Algolia Search样式并不美观，需要花一些时间调整。

![algolia search](https://s2.loli.net/2023/06/03/1niXoPeCBhOb3uj.webp)

### Layout

`Layout`组件的`slot`是自定义VitePress博客的要点，正是因为有了`slot`才使VitePress在默认主题下页面仍有一定可拓展的空间，`Layout`一共有3种布局，我只使用了`home`和`doc`，没有使用`page`布局。

我的博客一共使用了5个`slot`用于插入自定义的VUE组件：

| Slot                 | Component    | Function                               |
| -------------------- | ------------ | -------------------------------------- |
| doc-top              | \<Progress/> | 在页面顶部显示阅读进度条               |
| doc-after            | \<Comments/> | 在博客文章的末尾提供评论区             |
| aside-outline-before | \<Avatar/>   | 在右侧加入\<Member/>显示头像和联系方式 |
| home-hero-before     | \<Hero/>     | 在主页显示头像和一些简短的描述         |
| home-hero-after      | \<Page/>     | 按时间排序分页显示所有发布的博客文章   |

#### Progress.vue

这个组件比较特殊，虽然我使用了doc-top插槽，但实际上它可以根据需要放在任何一个插槽中，因为我使用了`<Teleport to="body"/>`来将这个组件传送到了外层的body中。

#### Comments.vue

对于博客来说，评论区很重要，这也能充实博客页面的空间，我尝试了3种解决方案：

- [Disqus](https://disqus.com/)
- [Gitalk](https://github.com/gitalk/gitalk)
- [Giscus](https://github.com/giscus/giscus)

Disqus和Gitalk存在我无法解决的Bug，Giscus官方的Vue组件也有Bug，最终被放弃，只有下面这一种方法是靠谱的。

Giscus有以下优点：

- 没有明显的样式或逻辑Bug；
- 使用GitHub Discussion而不是Issue；
- Transparent Dark主题能自适应网站配色。

以下代码可以完成构建一个美观`<Comments/>`组件的任务，具体的参数参照[giscus.app](https://giscus.app)。

`:key`用于阻止Vue组件重用，如果没有该属性，评论区在页面路由后不能正常更新。`useRoute`、`useRouter`中的数据不是响应式的，不可以用于`:key`。

::: code-group

```vue {4,10-11,23} [comments.vue]
<script setup lang="ts">
import {useData} from 'vitepress'

const {title} = useData()
</script>

<template>
  <div class="comments">
    <component
        :is="'script'"
        :key="title"
        src="https://giscus.app/client.js"
        data-repo="......"
        data-repo-id="......"
        data-category="......"
        data-category-id="......"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-lang="en"
        data-theme="transparent_dark"
        data-loading="lazy"
        async
    />
  </div>
</template>
```

```vue {10-12} [Layout.vue]
<script setup lang="ts">
import DefaultTheme from 'vitepress/theme'
import Comments from "./Comments.vue"

const {Layout} = DefaultTheme
</script>

<template>
  <Layout>
    <template #doc-after>
      <Comments/>
    </template>
  </Layout>
</template>

```

```typescript [index.ts]
import DefaultTheme from 'vitepress/theme'
import Layout from './components/Layout.vue'

export default {
    ...DefaultTheme,
    Layout: Layout,
}
```

:::

可以在加入类似`comments: false`的`frontmatter`，并在VUE中根据这一特征来决定是否加载Giscus来关闭评论。

这个功能很简单，但是锁定GitHub Discussion也可以做到，我认为没有必要再引入更多复杂性，所以没有加入。

![giscus](https://s2.loli.net/2023/04/30/bBUk9hIy8DpQaxG.webp)

#### Avatar.vue

这个组件很简单，为VitePress提供的`<VPTeamMembers/>`组件添加头像、描述和4个链接就完成了。

需要注意的是`.vue`文件可以用以下语法导入SVG文件，比`config.ts`方便的多。

这种方法导入的SVG图标触摸时不会显示文字，可以在SVG文件中添加`title`标签修复。

Vue+TypeScript需要一个`svg.d.ts`文件提供类型声明，否则将导致一个TS无法导入模块的报错。

::: code-group

```vue [Avatar.vue]
<script setup lang="ts">
import {VPTeamMembers} from 'vitepress/theme'
import email from '/email.svg?raw' // [!code ++]

const members = [
  {
    ...
    links: [
      {
        icon: {svg: email}, // [!code ++]
        link: 'mailto:hey@aiktb.com' 
      }
    ]
  }
]
</script>

<template>
  <VPTeamMembers size="small" :members="members"/>
</template>
```

```xml [email.svg]
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="email">
    <title>Email</title> // [!code ++]
    <path d=" ... "/>
</svg>
```

```typescript [svg.d.ts]
declare module '*.svg?raw' {
    import Vue, {VueConstructor} from 'vue'
    const content: VueConstructor<Vue>
    export default content
}
```

:::

![members](https://s2.loli.net/2023/04/30/HCjTzVPk4hlvOo3.webp)

#### Hero.vue & Page.vue

这两个组件构成了我的博客主页，主要参考了[clark-cui](https://visionary-sunflower-dc7ae3.netlify.app/)的博客，这并不复杂，仅仅依赖了在`frontmatter`中自定义的`title`和`date`。

![Page-Testing](https://s2.loli.net/2023/06/01/fLGkPngzjTIdau5.webp)

#### createContentLoader

`Page.vue`使用了这个函数用来获取`posts`目录下的所有`.md`文件数据，并且用`TypeScript`处理数据并渲染页面。

`createContentLoader`需要按照文档的说明新建立一个`posts.data.ts`文件来使用，因为这个函数无法在`.vue`文件中导入。

```typescript {9}
import {createContentLoader} from 'vitepress'

export interface Post {
    title: string
    url: string
    date: string
}

declare const data: Post[]
export {data}

export default createContentLoader('posts/*.md', {
    transform: (rawData) => {
        return rawData.sort((a, b) => {
            return +new Date(b.frontmatter.date) - +new Date(a.frontmatter.date)
        }).map(post => {
            return {
                title: post.frontmatter.title,
                url: post.url,
                date: formatDate(post.frontmatter.date)
            }
        })
    }
})

function formatDate(raw: string): Post['date'] {
    const date = new Date(raw)
    date.setUTCHours(12)
    return date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        }
    )
}
```

## Deploy

### GitHub Action

在这一点上我真的要称赞VitePress团队，因为[文档](https://vitepress.dev/guide/deploy#github-pages)中的`deploy.yml`文件不需要做任何修改就能在GitHub Action上直接使用，只需要将它放在你的`.github/workflow`目录下面。

这种方式有一个优点是可以滚动更新，你的服务不会下线，如果你还使用`github.io`子域，那么你将没有任何花费。

自定义域名非常简单，只需要两步：

1. 设置你的DNS解析记录一条`A`记录和`AAAA`记录指向GitHub的IPV4和IPV6地址，参考[文档](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain)；
2. 在以下GitHub仓库路径的设置将`Custom domain`设置为你想要的顶级域或子域。

```txt
https://github.com/${USER}/${REPO}/settings/pages
```

自定义域设置需要一些时间，如果你的域运行在Cloudflare的CDN上，而且以前申请过SSL证书，在这段时间你的网站会显示"526 Invalid SSL certificate"。

顺带一提，如果你在用Cloudflare的CDN，并且发现你的VitePress项目404页面无法正常显示，那么参考issue[#2270](https://github.com/vuejs/vitepress/issues/2270)。

![github-setting](https://s2.loli.net/2023/04/30/SJIm4oFneKt5hZf.webp)

### Others

VPS直接部署：

```zsh
git clone https://github.com/aiktb/rea.git
cd rea
npm install
tmux new-session -d 'npm run docs:build && npm run docs:preview'
```

终止服务：

```bash
tmux kill-session -t 0
```
